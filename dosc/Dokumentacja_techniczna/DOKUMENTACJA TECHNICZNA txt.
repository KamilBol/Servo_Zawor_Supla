SERVO MASTER: DOKUMENTACJA TECHNICZNA I HISTORIA PROJEKTU (V3.0 PLATINUM)
Autor: Kamil B贸l ("B贸lu") Data ukoczenia: Listopad 2025 Status: STABILNY (Production Ready)

 SPIS TRECI
WSTP I ZAO呕ENIA PROJEKTOWE

1.1 Cel projektu

1.2 Wymagania krytyczne

EWOLUCJA SPRZTOWA (HARDWARE)

2.1 Dlaczego ESP-01S poleg? (Analiza problemu)

2.2 Wemos D1 Mini: Zwycizca (Analiza Pinoutu)

2.3 Dob贸r Serwa: SG90 vs Standard

ANALIZA KODU 殴RDOWEGO (LINIJKA PO LINIJCE)

3.1 Biblioteki i Definicje

3.2 Zmienne Globalne i Pami

3.3 "GHOST BUSTER" - Serce Stabilnoci (Szczeg贸owy Opis)

3.4 Funkcje Serwisowe i Kalibracja

3.5 G贸wna Maszyna Stan贸w (loop)

ROZWIZANIE PROBLEMW (TROUBLESHOOTING - HISTORIA WALK)

4.1 Problem "Wiszcych Pin贸w" (Brak rezystor贸w)

4.2 Problem "Skaczcego Serwa" (Amnezja po restarcie)

4.3 Problem "Ptli Zwrotnej" (Szybki skok i powolny powr贸t)

4.4 Problem Blokowania Wemosa (Zy pin TX)

INSTRUKCJA OBSUGI DLA U呕YTKOWNIKA KOCOWEGO

5.1 Podczenie (Wiring)

5.2 Sygnalizacja LED (Co ona do mnie gada?)

5.3 Tryb Serwisowy (Bez komputera)

PODSUMOWANIE I WNIOSKI NA PRZYSZO

1. WSTP I ZAO呕ENIA PROJEKTOWE
1.1 Cel projektu
Zautomatyzowanie zaworu kulowego w instalacji C.O. (Centralnego Ogrzewania). System ma by elementem wykonawczym dla automatyki domowej (Supla), ale dziaa autonomicznie.

1.2 Wymagania krytyczne
Niezawodno: Zaw贸r nie mo偶e si sam otworzy/zamkn przez zak贸cenia.

Weryfikacja: Stan zaworu musi by potwierdzony fizycznym czujnikiem (kontaktronem), a nie "na wiar".

Pynno: Ruch ma by powolny (ok. 5 sekund), aby nie powodowa uderze hydraulicznych w rurach.

Failsafe: Po zaniku prdu sterownik musi wiedzie, w jakiej jest pozycji, i nie wykonywa gwatownych ruch贸w ("szarpania") przy starcie.

2. EWOLUCJA SPRZTOWA (HARDWARE)
2.1 Dlaczego ESP-01S poleg?
Na pocztku u偶yem ESP-01S.

Problem: Ten modu ma wyprowadzone tylko piny GPIO0 i GPIO2.

Konflikt: Te piny steruj trybem uruchamiania (BOOT MODE). Jeli podczymy tam serwo lub przycisk, kt贸ry zewrze je do masy przy starcie, ESP wejdzie w tryb programowania (FLASH) zamiast uruchomi kod.

Efekt: Cige restarty i niestabilno.

2.2 Wemos D1 Mini: Zwycizca
Wemos D1 Mini rozwiza wszystkie problemy z zasilaniem i pinami.

D1 (GPIO 5): Idealny do PWM (Serwo). Nie wpywa na bootowanie.

D2 (GPIO 4): Czyste wejcie cyfrowe.

D5 (GPIO 14): Czyste wejcie cyfrowe.

D0 (GPIO 16): Specyficzny pin z wbudowanym rezystorem pull-down (cigajcym do masy). Idealny na przycisk serwisowy, bo jest stabilny.

2.3 Dob贸r Serwa: SG90
Mae, tanie, ale kapryne.

Wymaga precyzji: Standardowa biblioteka Arduino Servo.h u偶ywa domylnych czas贸w impuls贸w, kt贸re dla SG90 s zbyt szerokie, powodujc "buczenie" i blokowanie na skrajnych pozycjach.

Rozwizanie: Musielimy rcznie zdefiniowa zakres mikrosekund (600us - 2400us).

3. ANALIZA KODU 殴RDOWEGO
Poni偶ej rozbieram nasz finalny kod na czynniki pierwsze.

3.1 Biblioteki i Pami
C++

#include <EEPROM.h> 
To kluczowa biblioteka. Pozwala zapisywa dane w pamici flash mikrokontrolera, kt贸re przetrwaj wyczenie prdu. Bez tego sterownik miaby amnezj po ka偶dym restarcie.

3.2 Zmienne Globalne
C++

int US_ZAMKNIETY = 600;   
int US_OTWARTY   = 2400;
Dlaczego zmienne int, a nie stae const? Bo w trybie serwisowym (przyciski D6/D7) my te wartoci zmieniamy w locie. Gdyby byy const, nie daoby si ich edytowa.

3.3 "GHOST BUSTER" - Serce Stabilnoci
To jest najwa偶niejsza funkcja w caym kodzie. Zastpuje fizyczny rezystor.

C++

bool sprawdzPin(int pin) {
  if (digitalRead(pin) == LOW) return false; // 1. Czytamy stan. Jak 0 to 0.
  
  // 2. Jeli jest 1 (HIGH), robimy "Test Obci偶enia".
  pinMode(pin, OUTPUT); 
  digitalWrite(pin, LOW); // Zwieramy pin do masy (wymuszamy 0V).
  delayMicroseconds(10);  // Czekamy 10 mikrosekund.
  pinMode(pin, INPUT);    // Wracamy do nasuchu.
  
  // 3. Sprawdzamy wynik walki.
  if (digitalRead(pin) == HIGH) return true; // Kabel wygra (Prawdziwy Sygna)
  return false; // Masa wygraa (To by tylko szum/zak贸cenie)
}
Dlaczego to dziaa? Szum elektromagnetyczny ma bardzo ma energi. Zwarcie do masy natychmiast go "zabija". Zasilacz 3.3V podczony kablem ma du偶 wydajno prdow i natychmiast "podnosi" napicie z powrotem.

3.4 Funkcja Ruchu (wykonajRuch)
Tutaj dzieje si magia sterowania serwem.

Anty-Szok Startowy:

C++

myServo.writeMicroseconds(startUS); 
myServo.attach(PIN_SERVO);
delay(200);
Najpierw ustawiamy "m贸zg" serwa na pozycj, w kt贸rej ono AKTUALNIE JEST (z pamici), a dopiero potem podczamy zasilanie sygnaowe (attach). Dziki temu serwo nie szarpie przy starcie.

Ptla Spowalniajca (Slow Motion): Zamiast kaza serwu "Jed藕 na 2400!", dzielimy tras na mae kroczki i wykonujemy je w ptli for. To daje nam ten pikny, 5-sekundowy ruch.

Cisza po Pracy:

C++

myServo.detach();
Po dojechaniu na miejsce odczamy sygna od serwa. Serwo przestaje "trzyma na si", przestaje bucze i nie pobiera prdu. Trzyma je tylko przekadnia (samohamowno).

3.5 Pami EEPROM
C++

EEPROM.put(ADRES_MEM, wartosc);
EEPROM.commit();
Po ka偶dym udanym ruchu zapisujemy now pozycj. Dziki temu po restarcie prdu w setup() mo偶emy j odczyta i wiedzie, gdzie jestemy.

4. ROZWIZANIE PROBLEMW (TROUBLESHOOTING)
4.1 Problem: "Wiszce Piny"
Objaw: Sterownik sam si wcza, diody mrugay bez powodu. Przyczyna: Brak rezystor贸w pull-down przy przyciskach. Rozwizanie: Funkcja sprawdzPin (Ghost Buster) opisana w rozdziale 3.3.

4.2 Problem: "Skaczce Serwo"
Objaw: Po wczeniu prdu serwo robio szybki ruch "bam!" w losow stron. Przyczyna: Biblioteka Servo domylnie ustawia pozycj 90 stopni przy starcie. Jeli zaw贸r by na 0, to serwo dostawao strza na 90. Rozwizanie: Pami EEPROM. Wczytujemy ostatni pozycj przed attach().

4.3 Problem: "Ptla Zwrotna"
Objaw: Serwo jechao na 100%, a potem powoli wracao. Przyczyna: Bd logiczny. Program zakada: "Skoro ka偶 mi zamkn, to na pewno jestem otwarty". A jeli czujnik kama, to program kaza serwu jecha tam, gdzie ju偶 byo (ale "na okoo"). Rozwizanie: Bezwzgldne sprawdzanie pozycji startowej z pamici. start = aktualnaPozycja. Jeli start == cel, blokujemy ruch.

4.4 Problem: "Zwiecha Wemosa"
Objaw: Po naciniciu przycisku zmiany logiki, Wemos przestawa dziaa, brak log贸w w PC. Przyczyna: U偶ywalimy pinu TX (GPIO 1) jako przycisku. Pin ten su偶y do wysyania danych do komputera. Zwarcie go do masy blokuje procesor. Rozwizanie: Przeniesienie funkcji na pin D0 (GPIO 16).

5. INSTRUKCJA OBSUGI (USER MANUAL)
5.1 Podczenie (Wiring)
D1: 呕贸ty kabel serwa.

D2: Sygna z Supli (plus).

D5: Kontaktron (plus).

GND: Wszystkie masy poczone razem!

5.2 Sygnalizacja LED
6 szybkich mrugni: "Wstaem. Melduj, 偶e zaw贸r jest ZAMKNITY".

3 szybkie mrugnicia: "Wstaem. Melduj, 偶e zaw贸r jest OTWARTY".

Dugie wiecenie (1s): "Odebraem rozkaz, bior si do roboty".

2 mrugnicia: "Ruszam silnikiem".

Mruganie powolne (2x): "BD! Dostaem rozkaz, ale czujnik m贸wi, 偶e ju偶 to zrobiem. Nie ruszam si dla bezpieczestwa".

5.3 Tryb Serwisowy
Zaw贸r nie domyka? Dotknij D6 kablem 3.3V. Kt zmniejszy si o kawaek.

Zaw贸r nie otwiera si do koca? Dotknij D7. Kt si zwikszy.

Odwrotny czujnik? Dotknij D0 i trzymaj 5 sekund. Sterownik odwr贸ci logik (Otwarty <-> Zamknity).

6. PODSUMOWANIE I WNIOSKI
Stworzylimy system klasy przemysowej na amatorskim sprzcie. Kluczem do sukcesu nie by drogi sprzt, ale inteligentne oprogramowanie, kt贸re radzi sobie z uomnociami fizycznymi (brak rezystor贸w, tanie serwo).

Co zapamita na przyszo?

Zawsze u偶ywaj pamici nieulotnej (EEPROM) w sterownikach, kt贸re maj stany (otwarty/zamknity).

Unikaj pinu TX/RX do sterowania.

Jeli nie masz rezystor贸w, musisz napisa kod, kt贸ry je "symuluje" (sprawdzPin).

Dobra diagnostyka (LED i Logi) oszczdza 90% czasu przy uruchamianiu.

Koniec Dokumentacji.
